## HTTP
HTTP 是一个应用层的无状态的超文本传输协议，它使用 TCP 作为传输层协议，保证了数据传输的可靠性。

* 应用层：应用层是网络应用程序和网络协议存放的分层，因特网的应用层包括许多协议，例如我们学 web 离不开的 HTTP，电子邮件传送协议 SMTP、端系统文件上传协议 FTP、还有为我们进行域名解析的 DNS 协议。在应用层要把各式各样的数据如字母、数字、汉字、图片等转换成二进制。
* 无状态：无状态是指协议对于事务处理没有记忆能力。在同一个连接中，两个执行成功的请求之间是没有关系的，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。
* 超文本：文本是指文字，超文本就是指文字、图片、音频、视频等等。

## HTTP发展历程
1. HTTP/0.9
最早版本是 1991 年发布的 0.9 版。该版本极其简单，只有一个命令 GET。TCP 连接（connection）建立后，客户端向服务器请求（request）网页 index.html。协议规定，服务器只能回应 HTML 格式的字符串，不能回应别的格式。服务器发送完毕，就关闭 TCP 连接。

2. HTTP/1.0
* 任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。
* 除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。
* HTTP 请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
* 新增功能还包括状态码**（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）**等。

3. HTTP/1.1
*  HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。
* 在 HTTP1.0 中主要使用 header 里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
* HTTP1.1 在请求头引入了range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
* 在 HTTP1.1 中新增了24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

4. HTTP/2
* HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。
* 多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。
* 浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。
* HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。
为了减少这块的资源消耗并提升性能， HTTP/2 对这些首部采取了压缩策略
* 服务端能通过 push 的方式将客户端需要的内容预先推送过去，也叫“cache push”。
服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确地请求，服务端可以提前给客户端推送必要的资源，这样可以减少请求延迟时间，例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不是等到 HTML 解析到资源时发送请求。

## HTTP与HTTPS的区别
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。HTTPS协议是由TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。主要区别：
* https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
* http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
* http和https使用的端口不一样，前者是80，后者是443。

## HTTPS加密机制
HTTPS使用非对称加密传输对称加密需要的秘钥，再通过对称加密的秘钥进行数据加密和传输。
1. 客户端生成一个随机数，将随机数和加密套件传输给服务端。服务端进行储存
2. 服务端生成一个随机数，将随机数和公钥传输给客户端。客户端进行储存
3. 客户端验证证书之后，再生成一个随机数（预主秘钥），并使用公钥进行加密，传输加密后的预主秘钥。
4. 服务端使用私钥（自带的）进行解密，获得预主秘钥。那么双方都已经有了三个随机数。通过加密套件生成一个主秘钥。
5. 使用主秘钥进行对称加密和传输。

相关知识
* 数字证书。网站在使用HTTPS前，需要向“CA机构”申请颁发一份数字证书，数字证书里有证书持有者、证书持有者的公钥等信息，服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以证明“该公钥对应该网站”。
* 数字签名。CA拥有非对称加密的私钥和公钥，CA对证书明文信息进行hash，对hash后的值用私钥加密，得到数字签名。浏览器验证过程：拿到证书，得到明文，数字签名。用CA机构的公钥对数字签名解密，用证书里说明的hash算法对明文进行hash。对比解密后的数字签名和hash过后的明文，相等表示可信。
* CA机构的公钥。操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥。
* 密钥保存。服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了

## 三次握手
相关知识：
* SYN(synchronous) 建立连接标志
* ACK(acknowledgement) 确认接收到的数据标志
* FIN(finish) 结束连接标志
* seq(sequence number) 序列号，被用来跟踪该端发送的数据量。每一个包中都包含序列号，当某个主机开启一个TCP会话时，他的初始序列号是随机的，可能是0和4,294,967,295之间的任意值。当是数据传输时，seq为上次对方传输的ack。
* ack(acknowledgment number) 确认号，在接收端则通过确认号用来通知发送端数据成功接收。当是数据传输时，ack为上次对方传输的seq+数据长度。

1. 第一次握手: 建立连接。客户端发送连接请求，发送SYN报文，将seq设置为0。然后，客户端进入SYN_SEND状态，等待服务器的确认。SYN seq=0。
2. 第二次握手: 服务器收到客户端的SYN报文段。需要对这个SYN报文段进行确认，发送ACK报文，将ack设置为1。同时，自己还要发送SYN请求信息，将seq为0。服务器端将上述所有信息一并发送给客户端，此时服务器进入SYN_RECV状态。SYN ACK seq=0，ack=1。
3. 第三次握手: 客户端收到服务器的ACK和SYN报文后，进行确认，然后将ack设置为1，seq设置为1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。ACK ack=1，seq=1。

## 四次挥手
1. 第一次挥手：客户端向服务器发送一个FIN报文段，将设置seq为160和ack为112;此时，客户端进入 FIN_WAIT_1状态,这表示客户端没有数据要发送服务器了，请求关闭连接;
2. 第二次挥手：服务器收到了客户端发送的FIN报文段，向客户端回一个ACK报文段，ack设置为161，seq设置为112;服务器进入了CLOSE_WAIT状态，客户端收到服务器返回的ACK报文后，进入FIN_WAIT_2状态;
3. 第三次挥手：服务器会观察自己是否还有数据没有发送给客户端，如果有，先把数据发送给客户端，再发送FIN报文；如果没有，那么服务器直接发送FIN报文给客户端。请求关闭连接，同时服务器进入LAST_ACK状态;ack设置为161，seq设置为112;
4. 第四次挥手：客户端收到服务器发送的FIN报文段，向服务器发送ACK报文段，将seq设置为161，将ack设置为113，然后客户端进入TIME_WAIT状态;服务器收到客户端的ACK报文段以后，就关闭连接;此时，客户端等待2MSL后依然没有收到回复，则证明Server端已正常关闭，客户端也可以关闭连接了。